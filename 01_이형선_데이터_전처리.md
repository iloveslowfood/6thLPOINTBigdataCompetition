**본 ipynb 파일은 Raw DATA의 NA 및 unknown 값을 정리하고, 자료형을 통일하기 위한 기본 전처리 코드로 실행하지 않을 것을 권고합니다. 본 코드의 결과물로는 (CKS) 라고 붙은 csv 파일이 DATA 폴더에 저장됩니다.**

# Library & Setting


```python
import pandas as pd
import numpy as np
import missingno as msno
from tqdm import tqdm_notebook as tq
pd.set_option('display.max_row',300)
%matplotlib inline
```

# Data Loading
## 온라인 행동 정보(online)


```python
online = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-01.온라인 행동 정보.csv')
online.info()
```

    C:\Users\trace\Anaconda3\lib\site-packages\IPython\core\interactiveshell.py:3058: DtypeWarning: Columns (9) have mixed types. Specify dtype option on import or set low_memory=False.
      interactivity=interactivity, compiler=compiler, result=result)
    

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 3196362 entries, 0 to 3196361
    Data columns (total 14 columns):
    clnt_id            int64
    sess_id            int64
    hit_seq            int64
    action_type        int64
    biz_unit           object
    sess_dt            int64
    hit_tm             object
    hit_pss_tm         int64
    trans_id           float64
    sech_kwd           object
    tot_pag_view_ct    float64
    tot_sess_hr_v      float64
    trfc_src           object
    dvc_ctg_nm         object
    dtypes: float64(3), int64(6), object(5)
    memory usage: 341.4+ MB
    

- 데이터를 불러올 때, 데이터의 자료형을 의미하는 dtype을 지정하지 않아 RAM 메모리가 부족하다는 low memory 경고가 발생합니다. 메모리 절약을 위해 dtype을 설정하도록 합니다.


```python
online_dtype = {'clnt_id':'int64', 
                'sess_id':'int64',
                'hit_seq':'int64',
                'action_type':'int64',
                'biz_unit':'category', # 카테고리 형태
                'sess_dt':'object', # 분석할 때 날짜 형태로 변경
                'hit_tm':'object', # 분석할 때 시간 형태로 변경
                'hit_pss_tm':'int64',
                'trans_id':'float64', # NaN을 지원하는 float64로 설정
                'sech_kwd':'object',
                'tot_pag_view_ct':'float64', # NaN을 지원하는 float64로 설정
                'tot_sess_hr_v':'float64', # NaN을 지원하는 float64로 설정
                'trfc_src':'category', # 카테고리 형태
                'dvc_ctg_nm':'object' # 추후에 카테고리로 변경
               }

online = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-01.온라인 행동 정보.csv', dtype=online_dtype)
online.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 3196362 entries, 0 to 3196361
    Data columns (total 14 columns):
    clnt_id            int64
    sess_id            int64
    hit_seq            int64
    action_type        int64
    biz_unit           category
    sess_dt            object
    hit_tm             object
    hit_pss_tm         int64
    trans_id           float64
    sech_kwd           object
    tot_pag_view_ct    float64
    tot_sess_hr_v      float64
    trfc_src           category
    dvc_ctg_nm         object
    dtypes: category(2), float64(3), int64(5), object(4)
    memory usage: 298.7+ MB
    

- 다음과 같이 dtype을 지정하도록 합니다.

## 거래 정보(trade)


```python
trade = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-02.거래 정보.csv')
```

- 거래 정보는 불러올 때 low memory 경고가 발생하지 않지만, 온라인 행동 정보와의 통일성 위해 dtype을 지정하도록 합니다.


```python
trade_dtype = {'clnt_id':'int64',
               'trans_id':'float64',
               'biz_unit':'category',
               'pd_c':'object', # 'unknown' 이라는 형태 존재
               'de_dt':'object',
               'de_tm':'object',
               'buy_am':'int64',
               'buy_ct':'int64'}
trade = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-02.거래 정보.csv', dtype=trade_dtype)
trade.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 599961 entries, 0 to 599960
    Data columns (total 9 columns):
    clnt_id      599961 non-null int64
    trans_id     599961 non-null float64
    trans_seq    599961 non-null int64
    biz_unit     599961 non-null category
    pd_c         599961 non-null object
    de_dt        599961 non-null object
    de_tm        599961 non-null object
    buy_am       599961 non-null int64
    buy_ct       599961 non-null int64
    dtypes: category(1), float64(1), int64(4), object(3)
    memory usage: 37.2+ MB
    

- 다음과 같이 dtype을 지정하도록 합니다.

## 고객 정보(customer)


```python
customer = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-03.고객 Demographic 정보.csv')
customer.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 72399 entries, 0 to 72398
    Data columns (total 3 columns):
    clnt_id        72399 non-null int64
    clnt_gender    72399 non-null object
    clnt_age       72399 non-null object
    dtypes: int64(1), object(2)
    memory usage: 1.7+ MB
    

- 고객 정보는 불러올 때 low memory 경고가 발생하지 않지만, 온라인 행동 정보와의 통일성을 위해 dtype을 지정하도록 합니다.


```python
customer_dtype = {'clnt_id':'int64',
                  'clnt_gender':'object',
                  'clnt_age':'object'}
customer = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-03.고객 Demographic 정보.csv',dtype=customer_dtype)
customer.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 72399 entries, 0 to 72398
    Data columns (total 3 columns):
    clnt_id        72399 non-null int64
    clnt_gender    72399 non-null object
    clnt_age       72399 non-null object
    dtypes: int64(1), object(2)
    memory usage: 1.7+ MB
    

- 다음과 같이 dtype을 지정하도록 합니다.

## 상품분류 정보(item)


```python
item = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-04.상품분류 정보.csv')
item.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 1667 entries, 0 to 1666
    Data columns (total 4 columns):
    pd_c        1667 non-null int64
    clac_nm1    1667 non-null object
    clac_nm2    1667 non-null object
    clac_nm3    1665 non-null object
    dtypes: int64(1), object(3)
    memory usage: 52.2+ KB
    

- 상품분류 정보는 불러올 때 low memory 경고가 발생하지 않지만, 온라인 행동 정보와의 통일성을 위해 dtype을 지정하도록 합니다.


```python
item_dtype = {'pd_c':'float64', # 거래 정보 데이터와 일치하도록 설정
              'clac_nm1':'category',
              'clac_nm2':'category',
              'clac_nm3':'category'}
item = pd.read_csv('./DATA/제6회 L.POINT Big Data Competition-분석용데이터-04.상품분류 정보.csv', dtype=item_dtype)
item.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 1667 entries, 0 to 1666
    Data columns (total 4 columns):
    pd_c        1667 non-null float64
    clac_nm1    1667 non-null category
    clac_nm2    1667 non-null category
    clac_nm3    1665 non-null category
    dtypes: category(3), float64(1)
    memory usage: 127.3 KB
    

- 다음과 같이 dtype을 지정하도록 합니다.

# Data Cleansing
## 온라인 행동 정보(online)
### 결측치 처리


```python
msno.bar(online, figsize=(12,6), color='steelblue')
```




    <matplotlib.axes._subplots.AxesSubplot at 0x253335f0b08>




![png](output_24_1.png)


- trans_id : trans_id는 고유의 거래 아이디이기 때문에 다른 수치로 대체할 수 없습니다.
- tot_pag_view_ct : NaN은 활동이 없었던 내용이라 가정하고 0으로 대체합니다.
- tot_sess_hr_v : NaN은 활동이 없었던 내용이라 가정하고 0으로 대체합니다.
- dvc_ctg_nm : NaN은 활동이 없는 기기 유형이지만, 기록이 되어야 하므로 trfc_src의 unknown으로 대체합니다.


```python
online.loc[online['tot_pag_view_ct'].isnull(),'tot_pag_view_ct'] = 0
online.loc[online['tot_sess_hr_v'].isnull(),'tot_sess_hr_v'] = 0
online.loc[online['dvc_ctg_nm'].isnull(),'dvc_ctg_nm'] = 'unknown'
online['tot_pag_view_ct'] = online['tot_pag_view_ct'].astype(np.int64)
online['tot_sess_hr_v'] = online['tot_sess_hr_v'].astype(np.int64)
online['dvc_ctg_nm'] = online['dvc_ctg_nm'].astype('category')
```

### 중복값 처리


```python
part = online[['clnt_id','sess_id','tot_sess_hr_v']]
blacklist = part.drop_duplicates().groupby(['clnt_id','sess_id']).size().to_frame('count').reset_index()
bl = blacklist[blacklist['count']>=2]
bl.head(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>clnt_id</th>
      <th>sess_id</th>
      <th>count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td>2</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>80</td>
      <td>17</td>
      <td>3</td>
      <td>2</td>
    </tr>
    <tr>
      <td>99</td>
      <td>23</td>
      <td>4</td>
      <td>2</td>
    </tr>
    <tr>
      <td>184</td>
      <td>40</td>
      <td>6</td>
      <td>2</td>
    </tr>
    <tr>
      <td>309</td>
      <td>49</td>
      <td>34</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



본래 세션 하나당 총 페이지 뷰 수와 총 세션 시간은 동일해야 합니다. 그러나 중복되는 세션들이 있습니다. 어떠한 이유인지 한 가지를 예시로 살펴봅니다.


```python
online[(online['clnt_id']==2)&(online['sess_id']==1)].sort_values('hit_seq').tail(5)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>clnt_id</th>
      <th>sess_id</th>
      <th>hit_seq</th>
      <th>action_type</th>
      <th>biz_unit</th>
      <th>sess_dt</th>
      <th>hit_tm</th>
      <th>hit_pss_tm</th>
      <th>trans_id</th>
      <th>sech_kwd</th>
      <th>tot_pag_view_ct</th>
      <th>tot_sess_hr_v</th>
      <th>trfc_src</th>
      <th>dvc_ctg_nm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1427756</td>
      <td>2</td>
      <td>1</td>
      <td>39</td>
      <td>5</td>
      <td>A03</td>
      <td>20190728</td>
      <td>23:48</td>
      <td>827645</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>55</td>
      <td>872</td>
      <td>DIRECT</td>
      <td>unknown</td>
    </tr>
    <tr>
      <td>1427653</td>
      <td>2</td>
      <td>1</td>
      <td>40</td>
      <td>5</td>
      <td>A03</td>
      <td>20190728</td>
      <td>23:48</td>
      <td>862074</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>55</td>
      <td>872</td>
      <td>DIRECT</td>
      <td>unknown</td>
    </tr>
    <tr>
      <td>1427645</td>
      <td>2</td>
      <td>1</td>
      <td>41</td>
      <td>5</td>
      <td>A03</td>
      <td>20190728</td>
      <td>23:48</td>
      <td>865245</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>55</td>
      <td>872</td>
      <td>DIRECT</td>
      <td>unknown</td>
    </tr>
    <tr>
      <td>1427707</td>
      <td>2</td>
      <td>1</td>
      <td>42</td>
      <td>5</td>
      <td>A03</td>
      <td>20190728</td>
      <td>23:49</td>
      <td>867734</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>55</td>
      <td>872</td>
      <td>DIRECT</td>
      <td>unknown</td>
    </tr>
    <tr>
      <td>1427606</td>
      <td>2</td>
      <td>1</td>
      <td>43</td>
      <td>5</td>
      <td>A03</td>
      <td>20190729</td>
      <td>00:01</td>
      <td>6880</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>6</td>
      <td>39</td>
      <td>DIRECT</td>
      <td>unknown</td>
    </tr>
  </tbody>
</table>
</div>



- 문제는  00:00에 있습니다. 자정이 넘어가면서, 총 페이지 뷰 수와 총 세션 시간이 다르게 기록됩니다. 그렇다면 이 둘을 더해야 정확한 자료가 될 것입니다. 저희는 이러한 중복값을 올바르게 된 총 페이지 뷰 수와, 총 세션 시간을 따로 저장하여 전처리했습니다.


```python
cl,ss,pv,hr = [[],[],[],[]]
for i in tq(range(len(bl))):
    unit = bl.iloc[i]
    data = online[(online['clnt_id']==unit['clnt_id'])&(online['sess_id']==unit['sess_id'])]
    cl.append(unit['clnt_id'])
    ss.append(unit['sess_id'])
    pv.append(data['tot_pag_view_ct'].unique().sum())
    hr.append(data['tot_sess_hr_v'].unique().sum())
right = pd.DataFrame({'clnt_id':cl,
                      'sess_id':ss,
                      'tot_pag_view_ct':pv,
                      'tot_sess_hr_v':hr})
```


    HBox(children=(IntProgress(value=0, max=1646), HTML(value='')))


    
    

- 먼저, 제대로 기록되어야 하는 값을 clnt_id와 sess_id 에 맞게 저장합니다.


```python
for i in tq(range(len(right))):
    unit = right.iloc[i]
    online.loc[(online['clnt_id']==unit['clnt_id'])&(online['sess_id']==unit['sess_id']),'tot_pag_view_ct'] = unit['tot_pag_view_ct']
    online.loc[(online['clnt_id']==unit['clnt_id'])&(online['sess_id']==unit['sess_id']),'tot_sess_hr_v'] = unit['tot_sess_hr_v']    
```


    HBox(children=(IntProgress(value=0, max=1646), HTML(value='')))


    
    

- 그리고 clnt_id와 sess_id에 맞는 제대로 된 수치로 변경합니다.

## 거래 정보(trade)


```python
trade['pd_c'].unique()
```




    array(['unknown', '0565', '0572', ..., '0689', '1078', '0305'],
          dtype=object)



- pd_c의 unknown은 종류를 알지 못하는 것으로 NaN으로 대체합니다. 다만 숫자가 '0454' 꼴의 형태로 기록되면 추후에 매칭이 어려울 수 있기 때문에 pd_c를 NaN을 지원하는 float 타입으로 변경합니다.


```python
trade.loc[trade['pd_c']=='unknown','pd_c'] = np.NaN
trade['pd_c']= trade['pd_c'].astype(np.float64)
```

## 고객 정보(customer)


```python
print(customer['clnt_gender'].unique())
print(customer['clnt_age'].unique())
```

    ['unknown' 'F' 'M']
    ['unknown' '30' '40' '20' '50' '60' '10']
    

- 'unknown'은 비식별 인원을 의미하는데, 추후 편리함을 위해 np.NaN으로 변경합니다. 그리고 성별은 카테고리 타입, 연령은 NaN을 지원하는 float 타입으로 변경합니다.


```python
customer.loc[customer['clnt_gender']=='unknown','clnt_gender'] = np.NaN
customer['clnt_gender'] = customer['clnt_gender'].astype('category')

customer.loc[customer['clnt_age']=='unknown','clnt_age'] = np.NaN
customer['clnt_age'] = customer['clnt_age'].astype(float)
```

# Data Saving

- 각 key 값의 순서별로 순서를 매겨 저장합니다.


```python
online = online.sort_values(['clnt_id','sess_id','hit_seq'])
online.to_csv('./DATA/온라인 행동 정보(CKS).csv', index=False)
```


```python
trade = trade.sort_values(['clnt_id','trans_id','trans_seq'])
trade.to_csv('./DATA/거래 정보(CKS).csv',index=False)
```


```python
customer = customer.sort_values('clnt_id')
customer.to_csv('./DATA/고객 정보(CKS).csv',index=False)
```


```python
item = item.sort_values('pd_c')
item.to_csv('./DATA/상품분류 정보(CKS).csv',index=False)
```
